Google Guava笔记：http://arcticfox9902.iteye.com/category/160901
浅析Google Guava中concurrent下的Monitor和Future特性：https://blog.csdn.net/a837199685/article/details/50610141
Google Guava Cache 全解析：https://www.imooc.com/article/34924

guava concurrent包的一个目的是要实现流式（链式）异步调用，是如何实现的?

CheckedFuture里有这要一段注释：
 * @deprecated {@link CheckedFuture} cannot properly support the chained operations that are the
 *     primary goal of {@link ListenableFuture}. {@code CheckedFuture} also encourages users to
 *     rethrow exceptions from one thread in another thread, producing misleading stack traces.
 *     Additionally, it has a surprising policy about which exceptions to map and which to leave
 *     untouched. Guava users who want a {@code CheckedFuture} can fork the classes for their own
 *     use, possibly specializing them to the particular exception type they use. We recommend that
 *     most people use {@code ListenableFuture} and perform any exception wrapping themselves. This
 *     class is scheduled for removal from Guava in October 2018.


Linux查找含有某字符串的所有文件：https://www.cnblogs.com/wangkongming/p/4476933.html

使用grep可以搜出某包下包含某字符串的文件：
$ grep -l "@since 1.0" *
AbstractCheckedFuture.java
AbstractExecutionThreadService.java
AbstractFuture.java
AbstractIdleService.java
AbstractService.java
Callables.java
CheckedFuture.java
ExecutionList.java
FakeTimeLimiter.java
ForwardingFuture.java
Futures.java
ListenableFuture.java
ListenableFutureTask.java
SimpleTimeLimiter.java
TimeLimiter.java
UncheckedTimeoutException.java

以上显示了concurrent包中，自1.0版本就存在的文件。

guava concurrent设置思想很超前，想实现的功能非常酷炫，能极大地的提高开发效率。（也有可能是我对jdk concurrent不够了解。）

问题：
1、MoreExecutors中我知道后续的动作是如何通过ListenableFuture.addListener添加到AbstractFuture的listtners上的，但是不明白这些listener是何时以怎么样的方式被调用的？
在使用addListener时，如果任务已经完成，则addListener里的新任务会立刻执行，但是，如果任务还没有完成，则addListener会放入listeners里等待任务完成，而任务完成后，listeners里的东西是
如何如何被调用的？难道有守护线程在处理？

见TrustedListenableFutureTask中的注释。

2、